#include <stdio.h>

/*
 * 求解一个1字节的变量(8bit)中1的个数
 *
 */

/*
//解法1  最简单的，一个数的位中是1的话，除以2会有余数1，是0的话，除以2余数是0
int count_of_1(int v)
{
	int num = 0;
	while (v){
		if (v % 2 == 1)
			num++;
		v /= 2;
	}

	return num;
}


//解法2 位操作。除以2过程，即向左移动一位，最右位直接丢弃
//把这个数和 00000001相与，得1的话表示最右位是1
//O(logn)
int count_of_1(int v)
{
	int num = 0;
	while (v){
		num += v&0x01;
		v >>= 1;
	}
	return num;
}
*/

//解法3 一次判断一个位上是1 即和其-1值相&，从右到左，一次一位1清0，n位1循环n次即可
// O(M),M为1的个数
int count_of_1(int v)
{
	int num = 0;
	while (v){
		v &= (v-1);
		num++;
	}
	return num;
}


//解法4，空间换取时间，一个字节对多256个数，将其所有值的1个数预先列出来在数组中，求值直接下标调用数组
//O(1)

int countTable[256] = {
  0,
  1,  1,  2,  1,  2,  2,  3,  1,  2,  2,  3,  2,  3,  3,  4,  1,  2,  2,  3,  2,  3,  3,  4,  2,  3,
  3,  4,  3,  4,  4,  5,  1,  2,  2,  3,  2,  3,  3,  4,  2,  3,  3,  4,  3,  4,  4,  5,  2,  3,  3,
  4,  3,  4,  4,  5,  3,  4,  4,  5,  4,  5,  5,  6,  1,  2,  2,  3,  2,  3,  3,  4,  2,  3,  3,  4,
  3,  4,  4,  5,  2,  3,  3,  4,  3,  4,  4,  5,  3,  4,  4,  5,  4,  5,  5,  6,  2,  3,  3,  4,  3,
  4,  4,  5,  3,  4,  4,  5,  4,  5,  5,  6,  3,  4,  4,  5,  4,  5,  5,  6,  4,  5,  5,  6,  5,  6,
  6,  7,  1,  2,  2,  3,  2,  3,  3,  4,  2,  3,  3,  4,  3,  4,  4,  5,  2,  3,  3,  4,  3,  4,  4,
  5,  3,  4,  4,  5,  4,  5,  5,  6,  2,  3,  3,  4,  3,  4,  4,  5,  3,  4,  4,  5,  4,  5,  5,  6,
  3,  4,  4,  5,  4,  5,  5,  6,  4,  5,  5,  6,  5,  6,  6,  7,  2,  3,  3,  4,  3,  4,  4,  5,  3,
  4,  4,  5,  4,  5,  5,  6,  3,  4,  4,  5,  4,  5,  5,  6,  4,  5,  5,  6,  5,  6,  6,  7,  3,  4,
  4,  5,  4,  5,  5,  6,  4,  5,  5,  6,  5,  6,  6,  7,  4,  5,  5,  6,  5,  6,  6,  7,  5,  6,  6,
  7,  6,  7,  7,  8
};

int main(int argc, const char *argv[])
{
	
	unsigned char v = 12;

	printf("%d\n",count_of_1(12));
	int i;
	for (i = 0; i <= 255; i++){
		countTable[i] = count_of_1(i);
	}
	
	printf("int countTable[256] = {\n");
	for (i = 0; i < 255; i++){
		printf("%3d,", countTable[i]);
		if (i % 25 == 0)
			printf("\n");
	}
	printf("%3d\n };\n", countTable[255]);
	return 0;
}
